/*
Copyright(c) 2021 by MandySoft

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files(the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#if defined(_WIN32) || defined(_WIN64)
#include <Windows.h>
#endif
#include <string>
#include <regex>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include "CKidMonBase.h"
#include <rapidcsv.h>

#define RULE_FILENAME "kidmon_rules.csv"
#define CHART_FILENAME "kidmon_chart.html"
#define DEFAULT_HOURS (14 * 24)
#define DEFAULT_DAYS 50
#define DEFAULT_WEEKS 53
#define DEFAULT_MONTHS 0

static int fVerbose = 0;
static int fDryRun = 0;

void debugf(const char* fmt, ...) {
    if (!fVerbose) {
        return;
    }
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
}

char* getCmdOption(char ** begin, char ** end, const std::string & option) {
    char ** itr = std::find(begin, end, option);
    if (itr != end && ++itr != end) {
        return *itr;
    }
    return 0;
}

bool cmdOptionExists(char** begin, char** end, const std::string& option) {
    return std::find(begin, end, option) != end;
}

int getCmdOptionInt(char ** begin, char ** end, const std::string & option, int defValue) {
    char *c = getCmdOption(begin, end, option);
    if (c) {
        try {
            return std::stoi(c);
        }
        catch (...) {
            return defValue;
        }
    } else {
        return defValue;
    }
}

std::string expandFileName(const char *filename) {
#ifdef _WINDOWS_
    char buffer[MAX_PATH];
    ExpandEnvironmentStringsA(filename, buffer, sizeof(buffer));
    std::string res(buffer);
#else
    std::string res(filename);
#endif
    return res;
}

bool fileExists(std::string filepath) {
    //std::ifstream stream;
    std::ifstream f(filepath);
    return f.good();
}

int getBasenameIdx(std::string filepath) {
    int idx = filepath.find_last_of("/\\");
    if (idx == std::string::npos) {
        idx = -1;
    }
    return idx + 1;
}

std::string readFile(std::string filename) {
    std::ifstream ifs(filename.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    std::ifstream::pos_type fileSize = ifs.tellg();
    ifs.seekg(0, std::ios::beg);

    std::vector<char> bytes((unsigned) fileSize);
    ifs.read(&bytes[0], fileSize);

    return std::string(&bytes[0], (unsigned) fileSize);
}

void writeFile(std::string filename, std::string &content) {
    std::ofstream ofs(filename.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);
    ofs << content;
}

template <typename T, std::size_t N>
constexpr std::size_t countof(T const (&)[N]) noexcept {
    return N;
}

int main(int argc, char *argv[]) {
    std::string exeFilename(argv[0]);
    int exeBasenameIdx = getBasenameIdx(exeFilename);

    std::string srcFilename(KIDMON_DATA_DIR KIDMON_HOURLY_RAW_FILENAME);
    std::string ruleFilename(exeFilename.substr(0, exeBasenameIdx) + RULE_FILENAME);
    std::string chartFilename(exeFilename.substr(0, exeBasenameIdx) + CHART_FILENAME);
    char *c;
    if (cmdOptionExists(argv, argv + argc, "-h")) {
        printf("KidMonDude v0.1, Copyright (c) 2021 by Mandysoft\n");
        printf("\n");
        printf("usage: %s [-h] [-v] [-d] [-n] [-r <rule_filename>] [-f <src_filename>] [-c <chart_filename>] [-H <hours>] [-D <days>] [-W <weeks>] [-M <months>]\n", exeFilename.substr(exeBasenameIdx).c_str());
        printf("\n");
        printf("Usage:\n");
        printf("  -h  print help\n");
        printf("  -v  print debug messages\n");
        printf("  -d  dry run\n");
        printf("  -n  do not rename source file\n");
        printf("\n");
        printf("  <rule_filename>   rules in CSV format, default: %s\n", ruleFilename.c_str());
        printf("  <chart_filename>  chart template, default: %s\n", chartFilename.c_str());
        printf("  <src_filename>    filename generated by Kidmon, default: %s\n", srcFilename.c_str());
        printf("  <hours>   period in hour database, default: %d\n", DEFAULT_HOURS);
        printf("  <days>    period in day database, default: %d\n", DEFAULT_DAYS);
        printf("  <weeks>   period in week database, default: %d\n", DEFAULT_WEEKS);
        printf("  <months>  period in month database, default: %d\n", DEFAULT_MONTHS);
        return -1;
    }
    if (cmdOptionExists(argv, argv + argc, "-v")) {
        fVerbose++;
    }
    if (cmdOptionExists(argv, argv + argc, "-d")) { 
        fDryRun++;
    }
    c = getCmdOption(argv, argv + argc, "-r");
    if (c) {
        ruleFilename = c;
    }
    c = getCmdOption(argv, argv + argc, "-c");
    if (c) {
        chartFilename = c;
    }
    c = getCmdOption(argv, argv + argc, "-f");
    if (c) {
        srcFilename = c;
    }
    srcFilename = expandFileName(srcFilename.c_str());
    debugf("Raw data: %s\n", srcFilename.c_str());
    if (!fileExists(srcFilename)) {
        fprintf(stderr, "File '%s' does not exist\n", srcFilename.c_str());
        return 1;
    }
    std::string srcFilename2;
    if (!fDryRun && !cmdOptionExists(argv, argv + argc, "-n")) {
        // rename file to do atomic operation vs. KidMon logger
        std::time_t t = std::time(nullptr);
        std::tm tm = *std::gmtime(&t);
        char buffer[16];
        std::strftime(buffer, sizeof(buffer), ".%Y%m%d%H%M%S", &tm);
        srcFilename2 = srcFilename + buffer;
        debugf("Rename to: %s\n", srcFilename2.c_str());
        if (rename(srcFilename.c_str(), srcFilename2.c_str()) != 0) {
            perror("Error renaming file");
            return 1;
        }
    } else {
        srcFilename2 = srcFilename;
    }
    // get directory
    size_t pos = srcFilename2.find_last_of("/\\");
    std::string dataDir(srcFilename2.substr(0, pos+1));  // including "/" if exists
    debugf("Data dir: %s\n", dataDir.c_str());


    struct AppMangle {
        bool contNextRule;
        bool applyInput;
        bool applyOutput;
        AppMangle(std::string aOptions) {
            contNextRule = aOptions.find('C') != std::string::npos;
            applyInput = aOptions.find('>') == std::string::npos || aOptions.find('<') != std::string::npos;
            applyOutput = aOptions.find('>') != std::string::npos;
        };
        AppMangle(const AppMangle &a) {   // copy constructors are not required here
            contNextRule = a.contNextRule;
        }
        virtual bool DoAction(std::string &name) const { return false; } // = 0;    vector cannot instantiate abstract class
        virtual ~AppMangle() {
            //debugf("destructor: %s\n", typeid(this).name());
        }
    };

    struct AppMangleRegex : AppMangle {
        std::regex regex;
        std::string replace;
        AppMangleRegex(std::string aOptions, std::string aRegex, std::string aReplace) : regex(), replace(aReplace), AppMangle(aOptions) {
            if (aOptions.find('I') != std::string::npos) {
                regex.assign(aRegex, std::regex::icase | std::regex::ECMAScript);
            } else {
                regex.assign(aRegex, std::regex::ECMAScript);
            }
        }
        AppMangleRegex(const AppMangleRegex &a) : AppMangle(a) {
            regex = a.regex;
            replace = a.replace;
        }
    };

    struct AppMangleRegexBasename : AppMangleRegex {
        int n;
        AppMangleRegexBasename(std::string aOptions, std::string aRegex, std::string aParam2) : AppMangleRegex(aOptions, aRegex, aParam2) {
            try {
                n = std::stoi(replace);
            } catch (...) {
                n = 0;
            }
        }
        AppMangleRegexBasename(const AppMangleRegexBasename &a) : AppMangleRegex(a) {
            n = a.n;
        }

        bool DoAction(std::string &name) const {
            if (!std::regex_search(name, regex)) {
                return false;
            }
            std::string name2;
            if (n >= 0) {
                int nn = n;
                size_t pos = std::string::npos;
                do {
                    size_t pos2 = name.find_last_not_of("/\\", pos);
                    if (pos2 == std::string::npos) {
                        break;
                    }
                    pos = pos2;
                    pos2 = name.find_last_of("/\\", pos);
                    if (pos2 == std::string::npos) {
                        pos = -1;
                        break;
                    }
                    pos = pos2;
                    nn--;
                } while (nn >= 0);
                name2 = name.substr(pos + 1);
            } else {
                int nn = -n;
                size_t pos = 0;
                do {
                    size_t pos2 = name.find_first_not_of("/\\", pos);
                    if (pos2 == std::string::npos) {
                        // delimiter at the end, should not happen
                        pos = name.length();
                        break;
                    }
                    pos = pos2;
                    pos2 = name.find_first_of("/\\", pos);
                    if (pos2 == std::string::npos) {
                        // leave at least basename if no more delim
                        break;
                    }
                    pos = pos2 + 1;
                    nn--;
                } while (nn > 0);
                name2 = name.substr(pos);
            }
            //debugf("RegexBasename(%d): %s->%s\n", n, name.c_str(), name2.c_str());
            name = name2;
            return !contNextRule;
        }
    };
    struct AppMangleRegexSearch : AppMangleRegex {
        AppMangleRegexSearch(std::string aOptions, std::string aRegex, std::string aReplace) : AppMangleRegex(aOptions, aRegex, aReplace) {};
        bool DoAction(std::string &name) const {
            if (std::regex_search(name, regex)) {
                //debugf("RegexSearch: %s->%s\n", name.c_str(), replace.c_str());
                name = replace;
                return !contNextRule;
            } else {
                return false;
            }
        }
    };

    struct AppMangleRegexReplace : AppMangleRegex {
        AppMangleRegexReplace(std::string aOptions, std::string aRegex, std::string aReplace) : AppMangleRegex(aOptions, aRegex, aReplace) {};
        bool DoAction(std::string &name) const {
            std::string name2 = std::regex_replace(name, regex, replace);
            if (name != name2) {
                //debugf("RegexReplace: %s->%s\n", name.c_str(), name2.c_str());
                name = name2;
                return !contNextRule;
            } else {
                return false;
            }
        };
    };

    // std::vector<std::reference_wrapper<AppMangle>> appMangling;   // we need reference as there is virtual function but it destroys objects as it is local to block
    std::vector<AppMangle*> appMangling;   // so we need pointers

    ruleFilename = expandFileName(ruleFilename.c_str());
    debugf("Rules: %s\n", ruleFilename.c_str());

    if (fileExists(ruleFilename)) {
        rapidcsv::Document csv(ruleFilename, rapidcsv::LabelParams(-1, -1), rapidcsv::SeparatorParams(';', true));
        for (size_t i = 0; i < csv.GetRowCount(); i++) {
            std::string op = csv.GetCell<std::string>(0, i);
            if (op.empty()) {
                continue;
            }
            struct AppMangle *o = nullptr;
            switch (op.c_str()[0]) {
                case 'B': {
                    o = new AppMangleRegexBasename(csv.GetCell<std::string>(1, i), csv.GetCell<std::string>(2, i), csv.GetCell<std::string>(3, i));
                    break;
                }
                case 'S': {
                    o = new AppMangleRegexSearch(csv.GetCell<std::string>(1, i), csv.GetCell<std::string>(2, i), csv.GetCell<std::string>(3, i));
                    break;
                }
                case 'R': {
                    o = new AppMangleRegexReplace(csv.GetCell<std::string>(1, i), csv.GetCell<std::string>(2, i), csv.GetCell<std::string>(3, i));
                    break;
                }
            }
            if (o) {
                appMangling.push_back(o);
            }
        }
    } else {
        fprintf(stderr, "File '%s' does not exist\n", ruleFilename.c_str());
        return 1;
    }

    chartFilename = expandFileName(chartFilename.c_str());
    debugf("Chart template: %s\n", chartFilename.c_str());
    std::string chartTemplate;

    if (fileExists(chartFilename)) {
        chartTemplate = readFile(chartFilename);
    } else {
        fprintf(stderr, "File '%s' does not exist\n", chartFilename.c_str());
        return 1;
    }

    struct CsvRow {
        std::string stampFormat;
        time_t stamp;  // we won't consider TZ, time is in localtime in CSV and we need as number only. The exception is comparison with period to delete old recs. But here it does not matter
        std::string appName;
        double cnt1;
        double cnt2;
        CsvRow(const char *stampFormat, std::string sLocalStamp, std::string appName, double cnt1, double cnt2) : stampFormat(stampFormat), appName(appName), cnt1(cnt1), cnt2(cnt2) {
            stamp = StrToTime(stampFormat, sLocalStamp);
        }
        CsvRow(const char *stampFormat, time_t utcStamp, std::string appName, double cnt1, double cnt2) : stampFormat(stampFormat), stamp(utcStamp), appName(appName), cnt1(cnt1), cnt2(cnt2) {
        }
        bool operator < (const CsvRow& r) const {
            if (stamp == r.stamp) {
                if ((cnt1 + cnt2) == (r.cnt1 + r.cnt2)) {
                    return appName < r.appName;
                } else {
                    return (cnt1 + cnt2) > (r.cnt1 + r.cnt2);
                }
            } else {
                return (stamp < r.stamp);
            }
        }
        std::string Round(double val) const {
            std::stringstream res;
            res << std::setprecision(3) << std::fixed << val;
            return res.str();
        }
        std::string GetStamp() const {
            return FormatStamp(stampFormat, stamp);
        }
        static time_t StrToTime(std::string fmt, std::string val) {
            std::istringstream ss(val);
            std::tm tm = { 0 };
            /* BUG: https://developercommunity.visualstudio.com/t/stdget-time-asserts-with-istreambuf-iterator-is-no/18311
            https://stackoverflow.com/questions/11213326/how-to-convert-a-string-variable-containing-time-to-time-t-type-in-c
            std::get_time() raises exception when format is longer than string value
            */
            std::regex r = std::regex("%V");
            if (std::regex_search(fmt, r)) {
                // get_time does not parse week, so we parse it as second and calculate correct date
                std::string fmt2 = std::regex_replace(fmt, r, "%S");
                ss >> std::get_time(&tm, fmt2.c_str());
                // https://stackoverflow.com/questions/48234612/how-to-get-a-date-from-a-year-and-iso-week-in-c
                int week = tm.tm_sec;   // 4-Jan-XXXX is always in 1st ISO week
                tm.tm_sec = 0;
                tm.tm_mon = 0;
                tm.tm_mday = 4;
                _mkgmtime(&tm);
                tm.tm_mday += 
                    (week - 1) * 7 - 
                    (tm.tm_wday + (7 - 1)) % 7;  // days since Monday in the 1st week
            } else {
                ss >> std::get_time(&tm, fmt.c_str());
                // it just parses string but does not fill remaining fields
                if (tm.tm_mday == 0) {
                    tm.tm_mday++;
                }
            }
            if (ss.fail()) {
                debugf("ERROR: StrToTime(%s, %s)\n", val.c_str(), fmt.c_str());
            }
            return _mkgmtime(&tm);   // just to get time_t as it would be UTC
        }
        static std::string FormatStamp(std::string fmt, time_t stamp) {
            struct tm *tm = gmtime(&stamp);
            char buff[20];
            strftime(buff, sizeof(buff), fmt.c_str(), tm);
            return buff;
        }
    };
    struct csvFile {
        std::string filename;
        std::string filepath;
        std::vector<CsvRow> rows;
        const char* stampFormat;
        int period;
        std::string chartKey;
    };

    struct csvFile csvFiles[5];
    csvFiles[0].filename = srcFilename2.substr(pos + 1);
    csvFiles[0].stampFormat = "%Y-%m-%d %H:%M";
    csvFiles[1].filename = KIDMON_HOURLY_FILENAME;
    csvFiles[1].stampFormat = "%Y-%m-%d %H:%M";
    csvFiles[1].period = getCmdOptionInt(argv, argv + argc, "-H", DEFAULT_HOURS) * 60 * 60;
    csvFiles[1].chartKey = "HOURLY";
    csvFiles[2].filename = KIDMON_DAILY_FILENAME;
    csvFiles[2].stampFormat = "%Y-%m-%d";
    csvFiles[2].period = getCmdOptionInt(argv, argv + argc, "-D", DEFAULT_DAYS) * 60 * 60 * 24;
    csvFiles[2].chartKey = "DAILY";
    csvFiles[3].filename = KIDMON_WEEKLY_FILENAME;
    csvFiles[3].stampFormat = "%Y-W%V";  // ISO week number
    csvFiles[3].period = getCmdOptionInt(argv, argv + argc, "-W", DEFAULT_WEEKS) * 60 * 60 * 24 * 7;
    csvFiles[3].chartKey = "WEEKLY";
    csvFiles[4].filename = KIDMON_MONTHLY_FILENAME;
    csvFiles[4].stampFormat = "%Y-%m";
    csvFiles[4].period = getCmdOptionInt(argv, argv + argc, "-M", DEFAULT_MONTHS) * 60 * 60 * 24 * 31;
    csvFiles[4].chartKey = "MONTHLY";

    for (unsigned int j = 0; j < countof(csvFiles); j++) {
        csvFiles[j].filepath = dataDir + csvFiles[j].filename;
        if (fileExists(csvFiles[j].filepath)) {
            debugf("Reading: %s\n", csvFiles[j].filepath.c_str());
            rapidcsv::Document csv(csvFiles[j].filepath, rapidcsv::LabelParams(-1, -1), rapidcsv::SeparatorParams(';', true));
            debugf("Row number: %d\n", csv.GetRowCount());
            for (size_t i = 0; i < csv.GetRowCount(); i++) {
                std::string appName = csv.GetCell<std::string>(1, i);
                // translate process names to a human name
                for (std::vector<AppMangle*>::iterator it = appMangling.begin(); it != appMangling.end(); ++it) {
                    if ((j == 0 && (**it).applyInput) || (j != 0 && (**it).applyOutput)) {
                        if ((**it).DoAction(appName)) {
                            break;
                        }
                    }
                }
                if (j == 0) {
                    const double MS_PER_HOUR = 1000.0 * 60.0 * 60.0;
                    struct CsvRow row(csvFiles[j].stampFormat, csv.GetCell<std::string>(0, i), appName, csv.GetCell<int>(2, i) / MS_PER_HOUR, csv.GetCell<int>(3, i) / MS_PER_HOUR);
                    csvFiles[j].rows.push_back(row);
                } else {
                    struct CsvRow row(csvFiles[j].stampFormat, csv.GetCell<std::string>(0, i), appName, csv.GetCell<double>(2, i), csv.GetCell<double>(3, i));
                    csvFiles[j].rows.push_back(row);
                }
            }
        }
    }

    // aggregate data
    for (std::vector<CsvRow>::iterator it1 = csvFiles[0].rows.begin(); it1 != csvFiles[0].rows.end(); ++it1) {
        time_t stamps[countof(csvFiles)];
        // calc stamp for particular database
        struct tm tm = *gmtime(&it1->stamp);
        tm.tm_min = 0;
        tm.tm_sec = 0;
        stamps[1] = _mkgmtime(&tm);
        tm.tm_hour = 0;
        stamps[2] = _mkgmtime(&tm);        
        int mday = tm.tm_mday - (tm.tm_wday + 6) % 7;  // IsoWeek starts on Monday, might be there one hour mistake on Sunday during DST change
        tm.tm_mday = 1;
        stamps[4] = _mkgmtime(&tm);
        tm.tm_mday = mday;
        stamps[3] = _mkgmtime(&tm);   // mkgmtime does day overflow mathematics, i.e. not needed //stamps[3] = stamps[2] - (((tm.tm_wday + 6) % 7) * 24 * 60 * 60);
        for (unsigned int j = 1; j < countof(csvFiles); j++) {
            bool found = false;
            for (std::vector<CsvRow>::iterator it2 = csvFiles[j].rows.begin(); it2 != csvFiles[j].rows.end(); ++it2) {
                if (it2->stamp == stamps[j] && it2->appName == it1->appName) {
                    it2->cnt1 += it1->cnt1;
                    it2->cnt2 += it1->cnt2;
                    found = true;
                    break;
                }
            }
            if (!found) {
                struct CsvRow row(csvFiles[j].stampFormat, stamps[j], it1->appName, it1->cnt1, it1->cnt2);
                csvFiles[j].rows.push_back(row);
            }
        }
    }

    time_t now;
    time(&now);
    for (unsigned int j = 1; j < countof(csvFiles); j++) {
        // find position where add CSV data to chart template
        std::string tag("// <__CSV_" + csvFiles[j].chartKey + "__>");
        size_t chartPos = chartTemplate.find(tag);
        if (chartPos != std::string::npos) {
            chartPos = chartTemplate.find_first_of("\r\n", chartPos);
            if (chartPos != std::string::npos) {
                chartPos = chartTemplate.find_first_not_of("\r\n", chartPos);
            }
        }
        if (chartPos == std::string::npos) {
            fprintf(stderr, "Chart template tag '%s' not found\n", tag.c_str());
            return 1;
        }
        tag = "// </__CSV_" + csvFiles[j].chartKey + "__>";
        size_t chartPos2 = chartTemplate.find(tag, chartPos);
        if (chartPos2 == std::string::npos) {
            fprintf(stderr, "Chart template tag '%s' not found\n", tag.c_str());
            return 1;
        }
        // remove existing tag content
        chartTemplate.erase(chartPos, chartPos2 - chartPos);
        chartTemplate.insert(chartPos, "``\n");  // javascript multi line string
        chartPos++;

        if (!csvFiles[j].rows.empty()) {
            debugf("Finalizing: %s, %d\n", csvFiles[j].filename.c_str(), csvFiles[j].period);
            // group potencial duplicate rows in output files (manual intervention or result of regex)
            for (std::vector<CsvRow>::iterator it1 = csvFiles[j].rows.begin(); it1 != csvFiles[j].rows.end(); ++it1) {
                if (it1->cnt1 + it1->cnt2 > 0) {
                    for (std::vector<CsvRow>::iterator it2 = it1 + 1; it2 != csvFiles[j].rows.end(); ++it2) {
                        if (it1->stamp == it2->stamp && it1->appName == it2->appName) {
                            debugf("Squezzing: %s;%s\n", it1->GetStamp().c_str(), it1->appName.c_str());
                            it1->cnt1 += it2->cnt1;
                            it2->cnt1 = 0;
                            it1->cnt2 += it2->cnt2;
                            it2->cnt2 = 0;
                        }
                    }
                }
            }
            // sort rows
            debugf("Sorting\n");
            std::sort(csvFiles[j].rows.begin(), csvFiles[j].rows.end());
            // feed to csv object
            debugf("Preparing output CSV\n");
            rapidcsv::Document csv("", rapidcsv::LabelParams(-1, -1), rapidcsv::SeparatorParams(';', true));
            size_t idx = 0;
            for (std::vector<CsvRow>::iterator it = csvFiles[j].rows.begin(); it != csvFiles[j].rows.end(); ++it) {
                if (it->cnt1 == 0 && it->cnt2 == 0) {
                    continue;
                }
                if (csvFiles[j].period > 0 && difftime(now, it->stamp) > csvFiles[j].period) {
                    debugf("Skipping expired row: %s;%s;%s;%s\n", it->GetStamp().c_str(), it->appName.c_str(), it->Round(it->cnt1).c_str(), it->Round(it->cnt2).c_str());
                    continue;
                }
                csv.SetCell<std::string>(0, idx, it->GetStamp());
                csv.SetCell<std::string>(1, idx, it->appName);
                csv.SetCell<std::string>(2, idx, it->Round(it->cnt1));
                csv.SetCell<std::string>(3, idx, it->Round(it->cnt2));
                std::ostringstream row;
                row << csv.GetCell<std::string>(0, idx) << ";" << csv.GetCell<std::string>(1, idx) << ";" << csv.GetCell<std::string>(2, idx) << ";" << csv.GetCell<std::string>(3, idx) << "\n";
                chartTemplate.insert(chartPos, row.str());
                chartPos += row.str().length();
                if (fDryRun) {
                    std::cout << row.str();
                }
                idx++;
            }
            if (!fDryRun) {
                // save csv files
                debugf("Writing: %s\n", csvFiles[j].filepath.c_str());
                csv.Save(csvFiles[j].filepath);
            }
        }
    }

    if (!chartTemplate.empty() && !fDryRun) {
        int idx = getBasenameIdx(chartFilename);
        std::string filepath(dataDir + chartFilename.substr(idx));
        debugf("Writing chart: %s\n", filepath.c_str());
        writeFile(filepath, chartTemplate);
    }
    debugf("Done\n");

    return 0;
}

